CSE 331 Homework 5.  Answers to written questions.
Edit this file to supply your answers.

Name:  Haopeng Zhou

1. What changes did you make to NullnessExample.java?
    I create an instance of Object so that myObject is not null.
    The reason is that the code is trying to dereference myObject, which is null, therefore cause the problem.
    By making it non-null the checker does not complain about it.

2. What changes did you make to the files we gave you in the hw5 package?
    LinkedtListNode:
        I remove all @Nullable annotation for class field, label, and the parameter label in
        the first constructor. Because the rep Invariant does not allow label to be null.

        I add @Nullabel for class field, next, the parameter for setNext() and return type for getNext(),
        because the next field for a node can be null, for example, a node at the end of a list.


    In AnotherNullnessExample class, since the spec does not allow the parameter for add method to be null,
    I create an instance and assign it to the node3. Therefore, when the list adds the node3, it will not pass a null.

    I also remove the node2.setLabel(null), since the spec for setLabel require the parameter to be non-null

3. 

a. Did the Nullness Checker indicate any problems with your specifications or code? If so what were they?
    The Nullness checker indicates that I am possibly dereference null in method addEdge and removeEdge.
    The problem is that I called other methods like containNode/containEdge to make sure that whenever i call
    map.get(node), this node must be in the map. However, the Nullness checker is not strong enough to infer it.



b. How did you change your specification or code to account for problems discovered by the Nullness Checker? For each change, also state why the change needed to be made.
    First, I am trying to add some annotations to inform the Nullness checker.
    Nonetheless, I figure out I can simply check if the node is in the map by calling map.containsKey(node). Moreover,
    I think this design makes each method interdependent, and therefore increasing cohesion.
    As a result, I choose to keep this design and do not bother with the annotations.



