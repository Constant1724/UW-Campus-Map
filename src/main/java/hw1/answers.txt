CSE 331 Homework 1.  Answers to Written questions.
Edit this file to supply your answers.

Name:  Haopeng Zhou

Problem 6.

(a)
The original implementation mistakenly classifies 0 as negative number.
To fix it, simply remove replace 'n <= 0' with 'n < 0' in the first if clause. (line 19)

(b)
According to the spec, the base case is the case when n = 0. Since the original implementation mistakenly classify
0 as negative number, the implementation will throw exception rather than return natural number 1.
To fix it, simply remove replace 'n <= 0' with 'n < 0' in the first if clause. (line 19)

(c)
According to the spec, the subsequent term (n>1) is the sum of two previous term, however the implementation did
subtraction between previous two terms instead of addition.
Furthermore, the third term should be the sum of two previous term. However, the implementation considers 'n=2' as
basic case, which is wrong according to the definition of Fibonacci number.

The implementation is inconsistent with the spec.

To fix it, replace the minus sign with add sign in the return clause (line 24)
and replace 'n <= 2' with 'n < 2' in the first else if clause. (line 21)

Problem 7. 
 (a)
    The implementation has 2 errors.
    First, in instructor, the original implementation assigns the variable volume to itself. The reason is that,
    according to java syntax, local variable has higher priority when referenced, if duplicated with class variable.

    To fix it, replace 'volume = volume' with 'this.volume = volume' (line 15)

    Second, in getVolume method, the implementation always return 0 regardless, which is inconsistent with
    the spec of the method, 'return the volume of the ball'.
    To fix it, replace 'return 0' with 'return this.volume' (line 24)
 (b)
    The answer depends. If the implementation does not mean to face huge load (small number of balls is expected),
    then it would be fine to loop through the set and add up the volume. It will be easier to implement.

    However, on the contrary, if the implementation is expected to run fast as the program scales
    (large number of balls is expected), then the second approach wins since it takes O(1) to run. It will be a little
    harder to implement.
 (c)
    The first implementation is to loop through the iterator returned by ballContainer and sort it by using SortedSet or
    ArrayList.sort() and get the final iterator.

    The second implementation is to maintain another sorted data structure beside ballContainer to have the iterator
    return sorted elements. In this case, the sorted data structure only cares about order and we have to modify the
    remove, add and clear method to keep the sorted data structure up-to-date with the original one.

    The answer to the question that which one is better really depends on the situation.
    For example, the first implementation favors the situation that the implementation does not face huge load
    (large number of balls is not expected) or the hardware is really powerful,
    thus looping through all balls should not take too long. The first implementation is easier to program.

    The second implementation favors the situation that huge number of balls is expected. In such case, looping through
    all balls is extremely time-consuming. Though it may take more memory, the program will respond faster.

