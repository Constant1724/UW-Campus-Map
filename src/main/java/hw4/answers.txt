CSE 331 Homework 4.  Answers to Written questions.
Edit this file to supply your answers.

Name:  Haopeng Zhou

Problem 1. (Choosing a representation)
//TODO delete waste section, after checking piazza.
(a)
    Collection of Edges:
        Advantages: It will be the easiest to implement, since we can just put all edges in a collection.

        Disadvantages: Runtime complexity will be bad, since for operations involving find a specific node, it has to
        go through the entire collection each time.

        // waste
        Runtime complexity will be very low for operations like: addNode, and removeNode. Since we do not
                allow duplicate nodes and removeNode shall always remove any Edges including that node, we have to go through
                the entire collection each time.

    Adjacency List:
        Advantages: For operation like finding a specific node/edge, it will be faster since it is holding the
        list of Nodes, and lists of edges with the same start node. For a graph, I am expecting client to use more
        finding operations than modifying the graph constantly.

        // Waste
        It will have space complexity, if it has fewer edges. For run time complexity, adding operations
        will be fast, since we are holding the list of Nodes, and list of edges for each starting node. It will be a
        little harder to implement than a collection of edges, but it is still relatively easy, since java has built in
        structures.

        Disadvantages: For operations like checking if two nodes are adjacent, it has go through the list of all Nodes
        and see if there is an edge exist. Normally in a graph, we are expecting more Nodes than edges, so I count it as
        an disadvantage. For example, we would not want google map to search all nodes in WA, if i am only looking for
        edges in UW campus.

    Adjacency Matrix:
        Advantages: For operations like checking if two nodes are adjacent, it has a super advantage over the other two
        representation, since it only needs to check the matrix at specific point, which is O(1).

        Disadvantages: Space complexity. Usually, the graph is sparse, since in a map, it is not true that
        there will be edges among most of the Nodes. As a result, lots of space in the matrix will be useless and thus
        a waste of space.


(b)
    I will choose Adjacency list, since it is moderately easy to implement. It also has advantages in space complexity,
    since most maps are sparse graphs. However, it does have runtime complexity problems considering
    removing operations. For removeEdge, it has to go through the list of Nodes, find the node and then find the edge.
    For removeNode, it has to go through all edges to make sure all edges containing that node are removed as well.


Problem 4.  (Additional tests and changes to specifications)

Update node/edge construtor and its spec, since its class fields are defined.
Update getters to emphasize the unmodifiability of return values.


