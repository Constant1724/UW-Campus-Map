CSE 331 Homework 4.  Answers to Written questions.
Edit this file to supply your answers.

Name:  Haopeng Zhou

Problem 1. (Choosing a representation)
(a)
    Collection of Edges:
        Advantages: It will be the easiest to implement, since we can just put all edges in a collection.
        Space complexity will be good, since it stores only edges and nothing more.

        Disadvantages: Runtime complexity will be bad, since for operations involving find a specific node
        or list all out-edges from one specific node, it has to go through the entire collection every time.

    Adjacency List:
        Advantages: For operation like finding a specific node/edge, it will be constant time since it is holding the
        list of Nodes, and lists of edges with the same start node. Moreover, it is also constant time to
        list all out-edges from one specific node. For a graph, I am expecting client to use more finding operations
        than modifying the graph constantly.

        Disadvantages: For operations like checking if two nodes are adjacent, it has go through the list of all Nodes
        and see if there is an edge exist. Normally in a graph, we are expecting more Nodes than edges, so I count it as
        an disadvantage. For example, we would not want google map to search all nodes in WA, if i am only looking for
        edges in UW campus.

    Adjacency Matrix:
        Advantages: For operations like checking if two nodes are adjacent (In other words, if a certain edge exist),
        it has a super advantage over the other two representation, since it only needs to check the matrix
        at specific point, which is O(1).

        Disadvantages: Space complexity. Usually, the graph is sparse, since in a map, it is not true that
        there will be edges among most of the Nodes. As a result, lots of space in the matrix will be useless and thus
        a waste of space. For Runtime complexity, finding all edges starting from one specific node is also slow, since
        it has to check the entire row in the matrix.


(b)
    I will choose Adjacency list, since it is moderately easy to implement. It also has advantages in space complexity,
    since most maps are sparse graphs. It does have runtime complexity problems considering
    removing operations. For removeNode, it has to go through all edges to make sure all edges containing
    that node are removed as well. However, for finding operations and listing all edges from one Node, Adjacency list
    has runtime complexity advantage. I consider these operations more important than others.


Problem 4.  (Additional tests and changes to specifications)
TESTS:
    I add two tests to test if getNodes/getEdges return an unmodifiable review of the nodes/edges. The reason is that
        I modify the spec to make it stronger by mention the return view of nodes/edges is unmodifiable, and therefore
        I have to add corresponding test.

    In addition, I replace all assertSame with assertEquals, since assertEquals calls equals method.

    By the way, I delete the test part for findPath, since I delete the findPath method, since i realize that
        we haven't touch it in class.

    Beside this, I feel like the original test is sufficient since other implementations are just as strong as the spec.
        I did not make a stronger implementation, so the original test against spec should be sufficient.

Changes:
    First of all, I update the constructor for node & edge classes since class fields are defined for now.

    Secondly, as i mentioned above, I strengthen the spec for getNodes/getEdges by adding the word "unmodifiable"
        in front of the return type. Because, I would like to explicit tell the client that representation exposure
        in these two methods are not possible.

    Finally, I delete the findPath method, since i realize that we haven't touch it in class.


